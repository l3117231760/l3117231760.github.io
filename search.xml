<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>两数相加</title>
      <link href="/2022/092216124.html"/>
      <url>/2022/092216124.html</url>
      
        <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为都是逆序直接相加就可以！！不过要注意以下几个方面</p><ol><li><font size="5">要及时时更新节点比如l1=l1->next</font></li><li><font size="5">要注意在其中一个数子没有第二个长的时候，单独一个数字也可以产生进位[9,9,9,9] [9,9,9,9,9,9]</font></li><li><font size="5">要注意最后可能进位还有而数字链表没了，还需要开辟一个空间来存放进位</font></li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class=" language-lang-c"><code class="language-lang-c">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * };; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){        struct ListNode* result=(struct ListNode*)malloc(sizeof(struct ListNode));        struct ListNode* index=result;        int x=0;        while(l1 && l2)        {            struct ListNode*node=(struct ListNode*)malloc(sizeof(struct ListNode));            index->next=node;            index=node;            node->next=NULL;            if(l1->val+l2->val+x>9)            {                node->val=l1->val+l2->val+x-10;                x=1;            };else            {                node->val=l1->val+l2->val+x;                x=0;            };                  l1=l1->next;                  l2=l2->next;        };        if(l1!=NULL)        {            while(l1!=NULL)            {                struct ListNode*node=(struct ListNode*)malloc(sizeof(struct ListNode));                index->next=node;                index=node;                node->next=NULL;                if(l1->val+x>9)                {                    node->val=l1->val+x-10;                    x=1;                };else                {                       node->val=l1->val+x;                       x=0;                };                l1=l1->next;            };        };            if(l2!=NULL)        {            while(l2!=NULL)            {                struct ListNode*node=(struct ListNode*)malloc(sizeof(struct ListNode));                index->next=node;                index=node;                node->next=NULL;                if(l2->val+x>9)                {                    node->val=l2->val+x-10;                    x=1;                };else                {                    node->val=l2->val+x;                    x=0;                };                l2=l2->next;            };        };        if(x!=0)        {            struct ListNode*node=(struct ListNode*)malloc(sizeof(struct ListNode));            index->next=node;            node->val=x;            node->next=NULL;        };        return result->next;};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09200.html"/>
      <url>/2022/09200.html</url>
      
        <content type="html"><![CDATA[<h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-主存的基本组成"><a href="#1-主存的基本组成" class="headerlink" title="1.主存的基本组成"></a>1.主存的基本组成</h3><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209202018592.png" alt="image-20220920201821366"></p><ul><li><font size="5">MAR：地址寄存器</font></li><li><font size="5">MDR  :主存数据寄存器  </font> </li></ul><p>​      地址总线发送需要读写的地址，经过译码器的译码，然后控制电路和读写电路控制是由存储体写入还是读出数据，**但是这个数据并不是指的是传统意义上的数据他可以是也可以是指令代码或状态信息，有时甚至是一个控制信息，cs：ip，指向的数据就是指令，其他的都算数据。</p><h3 id="2-主存和CPU的联系"><a href="#2-主存和CPU的联系" class="headerlink" title="2.主存和CPU的联系"></a>2.主存和CPU的联系</h3><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209202020065.png" alt="image-20220920202000992"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言中数据的存储</title>
      <link href="/2022/091916123.html"/>
      <url>/2022/091916123.html</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中数据的存储"><a href="#C语言中数据的存储" class="headerlink" title="C语言中数据的存储"></a>C语言中数据的存储</h1><p><strong>C语言中的数据类型有很多：整形、浮点型、自定义类型，指针类型、void型。</strong></p><font color="blue">       在计算机中数据以二进制的方式进行存储，C语言中定义变量就是在开辟空间，这个空间就像一个模子，放进去的时候不管他是是什么，出来的时候就是模子的形状，定义变量也是一样，不管他是怎么样的数据，他都会把数据放到你开辟的空间中去，当“边角料”过多就会发生截断，把多余的部分进行舍弃，C是保存位于低位的数据或者说是底权值的数据，只有在进行使用的时候才会关注它本身的性质进行解释而已。</font><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.alicdn.com%2Ftfscom%2Fi1%2F2834243173%2FTB2yPBfkwZC2uNjSZFnXXaxZpXa_!!2834243173.jpg&amp;refer=http%3A%2F%2Fimg.alicdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1666157901&amp;t=be9e53df5f1b168c4c4d2061610294f2" alt="img"></p><h2 id="整形数据的存储"><a href="#整形数据的存储" class="headerlink" title="整形数据的存储"></a>整形数据的存储</h2><pre class=" language-lang-c"><code class="language-lang-c">charint shortlonglong long</code></pre><font color="red">这里不考虑大小端的问题，因为存进去的时候需要遵循大小端的规则，在取出来的时候同样需要遵循大小端的规则！！！</font><ul><li>C语言中数据的存储为补码进行存储的，在数据的存储过程中其中第一位为符号位，其中0表示这个数为正，1表示这个数为负数，其中正数的原码、反码、补码是相同的，即十进制转化为二进制是什么样子就是什么样子，拿int来进行举例：</li></ul><pre class=" language-lang-c"><code class="language-lang-c">100000 0000 0000 0000 0000 0000 0000 1010 //原码0000 0000 0000 0000 0000 0000 0000 1010 //反码0000 0000 0000 0000 0000 0000 0000 1010 //补码38=32+4+20000 0000 0000 0000 0000 0000 0010 0110//原码0000 0000 0000 0000 0000 0000 0010 0110//反码0000 0000 0000 0000 0000 0000 0010 0110//补码</code></pre><ul><li><p>C语言中负数的存储，原码、反码、补码便不再相同了拿int来进行举例：</p><p><strong>原码-&gt;补码</strong></p></li></ul><p>​                反码 = 原码按位取反但是符号位不变</p><p>​                补码 = 反码 + 1</p><p>​                <strong>补码-&gt;原码</strong></p><ol><li><p>先求反码  反码 = 补码 - 1（日常使用）</p><p>再求原码 原码=反码按位取反符号不变</p></li><li><p>再按 原码-&gt;补码的规则来一遍（计算机内部使用）</p><p>先符号位不变按位取反然后加一</p></li></ol><p>其中 负数的原码 + 补码 = 0；</p><pre class=" language-lang-c"><code class="language-lang-c">-101000 0000 0000 0000 0000 0000 1010 //原码1111 1111 1111 1111 1111 1111 0101 //反码                                +1----------------------------------1111 1111 1111 1111 1111 1111 0110 //补码-381000 0000 0000 0000 0000 0000 0010 0110 //原码1111 1111 1111 1111 1111 1111 1101 1001 //反码                                     +1------------------------------------------1111 1111 1111 1111 1111 1111 1101 1010 //补码</code></pre><h2 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h2><pre class=" language-lang-c"><code class="language-lang-c">floatdouble</code></pre><p>浮点数的存储是依据国际标准IEEE（电气与电子工程协会）754标准，任何一个二进制浮点数都可以表示成下面的形式</p><blockquote><ul><li>(-1)^S x M x 2^E</li><li>(-1)^S表示符号位</li><li>M表示有效数字 大于等于1 小于2</li><li>2^E表示指数位 ， float中 ， E为无符号数因为没有负数，所以把127当成0的分界点，需要把求得的数加上127</li></ul><p>下面有两条规定</p><ol><li>当E 为00000000的时候就把它当做接近于0  2的1-127次方 M前的一可以省略变为0.  …</li><li>当E 为全1的时候可以理解为正负无穷取决于符号位</li></ol></blockquote><p>其中符号位在浮点数中用一位来进行表示，其他的M和E各不相同</p><font size="6">float(4字节)</font>:![image-20220919141945131](https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209191506242.png)<font size="6">double（8字节）</font>:![image-20220919142218078](https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209191506035.png)```c5.5=4+1+0.5101.1=1.011*2^2S=0//E=2 //因为没有负数，所以把127当成0的分界点,小于127的为负数，需要加127 所以E=129E=129  M=011 //其中第一位的1可以舍弃，因为每个数1-2都有这个一可以不写如内存0 10000001 01100000000000000000000```可以来看下面的一串代码来练习一下```c#include<stdio.h>int main(){    int a = 9;    float *pi=(float*)&a;    printf("%d\n",a);    printf("%lf\n",*pi);    *pi=9.0;    printf("%d\n",a);    printf("%lf\n",*pi);    return 0;}```运行结果：![image-20220919143724552](https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209191506069.png)```c90000 0000 0000 0000 0000 0000 0000 10010 00000000 00000000000000000010001 //E全0在输出的时候为091001.0S=0E=130M=1.0010 10000010 001000000000000000000000 10000010 00100000000000000000000 //计算器写的```![image-20220919145614134](https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209191506687.png)<font color="red" size="4">正好对应上面的存数据的时候不用管他是什么类型，只需要把他的二进制信息存入对应变量开辟的内存，在取出的时候按照（int float等等）规则进行解释就可以了</font><h3 id="浮点误差的解决方法"><a href="#浮点误差的解决方法" class="headerlink" title="浮点误差的解决方法"></a>浮点误差的解决方法</h3><p>浮点数会有误差，就和我们十进制中的1/3一样是无限小数，可是存储的类型的内存是有限的，会产生误差，因为这种误差的存在当我们在进行判断的时候需要用其他的方式来。<img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209191735189.png" alt="image-20220919173532225"></p><p>可以通过引入</p><pre class=" language-lang-c"><code class="language-lang-c">#include<stdio.h>#include<float.h>#include<math.h>int main(){    double c=10.0;    double a=0.9;    if(c-a*10==0.1)    {        printf("bingo");    };    if(fabs(c-a*10)<FLT_DIG) //这里不能带等于    {        printf("xin bingo");    };    return 0;};</code></pre><p>输出</p><pre class=" language-lang-c"><code class="language-lang-c">xin binggo</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中的关键字</title>
      <link href="/2022/091616122.html"/>
      <url>/2022/091616122.html</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中的关键字"><a href="#C语言中的关键字" class="headerlink" title="C语言中的关键字"></a>C语言中的关键字</h1><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><blockquote><p>用来修饰局部变量，用来修饰全局变量会进行报错</p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209171726673.png" alt="image-20220917171949545"></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209171726632.png" alt="image-20220917172042579"></p></blockquote><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><blockquote><p>最快的关键字 建议把变量直接保存到cache里面去（或者说直接在cache里面开辟空间来存放数据）</p><p>注意： cache 中的为内存的映射没有地址 不可以对regirst修饰的变量进行取地址的操作</p><p>register只是建议把这个变量放到cache中并不是强制！！！  最终是否放到cache中还是要有编译器来进行决定</p><p>regirster关键字应当用在高频率读取的并不经常写入的变量上面，因为每一次写入都需要重新载入内存，然后在到cpu对其的值进行更改，最后写回内存，在写入cache会变的更加繁琐</p></blockquote><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209171726646.png" alt="image-20220917172127424"></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209171726640.png" alt="image-20220917172316038">extern</p><blockquote><p>extern 是用来进行声明的关键字（声明只是提前告诉编译器有这个东西并不会在内存中开辟空间）</p><p>extern在声明变量的时候不能进行赋值，因为声明并没有进行开辟空间!!!</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">extern void function();extern int a;</code></pre><p><strong>extern 用来声明变量或者来说声明函数</strong>，因为全局变量和函数是可以进行跨文件进行访问的，不进行声明的话在跨文件进行访问的时候变量会进行报错（显示变量未定义），而函数只会报LINK警告在编译的时候可以进行通过。</p><p>extern对变量、函数进行声明后便不会在进行报警或者报错了</p><h3 id="变量的跨文件访问"><a href="#变量的跨文件访问" class="headerlink" title="变量的跨文件访问"></a>变量的跨文件访问</h3><p><strong>text.c</strong></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161705858.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=bB6SO&amp;margin=%5Bobject%20Object%5D&amp;originHeight=249&amp;originWidth=804&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p><strong>main.c</strong></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161705801.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=369&amp;id=Id7GQ&amp;margin=%5Bobject%20Object%5D&amp;originHeight=291&amp;originWidth=634&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=804" alt=""></p><p><strong>会直接进行报错</strong></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161705338.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=250&amp;id=F5P20&amp;originHeight=127&amp;originWidth=409&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=806" alt=""></p><p><strong>Myfunction</strong>函数的跨文件访问:</p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161710186.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=346&amp;id=mtboD&amp;originHeight=269&amp;originWidth=621&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=799" alt=""></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161712654.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=126&amp;id=QXZer&amp;originHeight=145&amp;originWidth=888&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=769" alt=""></h2><p><strong>用extern进行声明后就会进行解决</strong></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161719337.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=361&amp;id=bCYD3&amp;originHeight=273&amp;originWidth=588&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=777" alt=""></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161720332.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=959&amp;id=FJK7g&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1344&amp;originWidth=1099&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=784" alt=""></p><h3 id="extern是声明不能进行赋值"><a href="#extern是声明不能进行赋值" class="headerlink" title="extern是声明不能进行赋值"></a>extern是声明不能进行赋值</h3><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161723109.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=1440&amp;id=RyQu3&amp;originHeight=1251&amp;originWidth=681&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=784" alt=""></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><blockquote><ol><li>static修饰的<strong>变量和函数</strong>不再能进行跨文件访问，只能在本文件内进行访问，<strong>若外部文件要对变量进行访问需要在本文件内提供接口函数来进行访问</strong> </li><li>static 修饰局部变量会改变局部变量的生命周期，即他的作用域还是其所在的代码块，不过函数执行完毕没有进行销毁 </li></ol><p>作用： static为项目维护提供安全保证</p></blockquote><h3 id="static-修饰局部变量会改变局部变量的生命周期"><a href="#static-修饰局部变量会改变局部变量的生命周期" class="headerlink" title="static 修饰局部变量会改变局部变量的生命周期"></a>static 修饰局部变量会改变局部变量的生命周期</h3><p><strong>如果在代码快外进行访问会进行报错，而在代码块内没有任何问题</strong></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161742620.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=365&amp;id=lhb4B&amp;originHeight=470&amp;originWidth=970&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=754" alt=""></p><hr><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209161736708.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;height=502&amp;id=GXnmZ&amp;originHeight=511&amp;originWidth=807&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=792" alt=""></p><p><strong>实验结论：对于临时变量，在函数返回后就已经被销毁了,但是指针p指向i的地址，如果回收就会打印随机值的，但是确正常进行打印了，说明static改变了变量的生命周期，而i不能在函数外进行访问，说明static没有改变变量的作用域；</strong></p><h3 id="那么为什么全局变量具有全局性"><a href="#那么为什么全局变量具有全局性" class="headerlink" title="那么为什么全局变量具有全局性"></a>那么为什么全局变量具有全局性</h3><p>变量存放的位置发生改变</p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202209171912304.png" alt="image-20220917191204546"></p><p><strong>这个并不是内存！！！，而是叫进程地址空间</strong></p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><blockquote><p>sizeof 是关键字而不是函数</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">#include<stdio.h>int main(){    int a = 10;    printf("%d\n",sizeof(a));  //正确的    printf("%d\n",sizeof(int));//正确的    printf("%d\n",sizeof a);   //正确的    printf("%d\n",sizeof int); //错误的    return 0;};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOS的基本原理</title>
      <link href="/2022/080316121.html"/>
      <url>/2022/080316121.html</url>
      
        <content type="html"><![CDATA[<h1 id="DOS的基本原理"><a href="#DOS的基本原理" class="headerlink" title="DOS的基本原理"></a>DOS的基本原理</h1><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202208030744061.png" alt="image-20220803074402314"></p><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202208030748728.png" alt="image-20220803074823539"></p><p><strong>相对路径：从当前目录开始定位，形成的一个路径</strong></p><p><strong>绝对路径：由D盘（顶级目录），开始定位，形成的路径</strong></p><blockquote><p>例如：假设当前在abc文件夹下的test100定位访问text200文件夹下的文件</p><p>相对路径： ../ 回到上一级</p><p>../../abc2/text200</p><p>绝对路径: d:/abc2/text200</p></blockquote><h2 id="Dos命令"><a href="#Dos命令" class="headerlink" title="Dos命令"></a>Dos命令</h2><ul><li>dir：当前目录有什么内容，后面可以直接接绝对路径</li><li>cd：切换盘符，打开，切换得到其他目录 cd /D c: ,cd ..返回上一级，cd \ 到根目录，后面可跟响度路径，也可以个绝对路径</li><li>del:删除路径</li><li>move：移动，剪切路劲</li><li>md：创建目录</li><li>echo：echo ok&gt;ok.txt将对应内容写入文件，echo nul&gt;ko.txt创建空目录</li><li>cls:清屏</li><li>exit:关闭Dos</li><li>tree：创建文件树</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA运行机制和开发细节</title>
      <link href="/2022/080316120.html"/>
      <url>/2022/080316120.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java运行机制和开发细节"><a href="#Java运行机制和开发细节" class="headerlink" title="Java运行机制和开发细节"></a>Java运行机制和开发细节</h1><h2 id="Java运行机制"><a href="#Java运行机制" class="headerlink" title="Java运行机制"></a>Java运行机制</h2><blockquote><p>在每一次修改代码后都需要进行编译，因为Java的执行<code>JVM</code>识别<code>.class</code>文件，没有进行Javac的编译就无法对<code>.class</code>文件进行修改</p></blockquote><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202208021411821.png" alt="image-20220802141016899"></p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202208021411075.png" alt="image-20220802141053819"></p><h2 id="Java开发细节"><a href="#Java开发细节" class="headerlink" title="Java开发细节"></a>Java开发细节</h2><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202208021416427.png" alt="image-20220802141633866"></p><ul><li>程序的入口（主方法）</li></ul><pre class=" language-lang-java"><code class="language-lang-java">public static void main (String[] args){....};</code></pre><ul><li><p>Java 区分大小写</p></li><li><p>一个源文件只能有一个public类但是其他类的个数不限制，但是只要有一个类，在编译以后都会形成一个对应的class类</p></li><li><p><strong>如果源文件中有public类，文件名一定要与public类名相同</strong></p></li><li><p>在非public类中同样可以写程序的入口（main 主方法 ）通过其类名来访问对应类的主方法</p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202208021426056.png" alt="image-20220802142543859"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（一）</title>
      <link href="/2022/042816113.html"/>
      <url>/2022/042816113.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（一）"><a href="#计算机组成原理（一）" class="headerlink" title="计算机组成原理（一）"></a>计算机组成原理（一）</h1><h2 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h2><h3 id="计算机的软硬件概念"><a href="#计算机的软硬件概念" class="headerlink" title="计算机的软硬件概念"></a>计算机的软硬件概念</h3><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202204281542904.png" alt="计算机组成原理.软硬件"></p><p>计算机系统由“<strong>软件</strong>”与“<strong>硬件</strong>”两大部分组成</p><ul><li>“<strong>硬件</strong>” ：计算机的实体部分，他是由看得见摸得着的各种元器件</li><li>“<strong>软件</strong>”：由人们事先编制的具有特殊功能的程序组成，看不见、摸不着。  </li></ul><p>计算机的软件又通常可以分为：“系统软件”和“应用软件”</p><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202204281528083.jpeg" alt="计算机原理.软件x"></p><p><strong>系统软件</strong>又称为系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度、高效运行。</p><p>包括：</p><ol><li><p>标准程序库</p></li><li><p>语言处理程序（将汇编语言翻译为机器语言的汇编程序或将高级语言翻译成机器语言的编译程序）</p></li><li>操作系统（批处理系统、分时系统、实时系统）</li><li>服务程序(诊断程序、调试程序、连接程序等)</li><li>数据库<strong>管理</strong>系统</li><li>网络软件等</li></ol><p><strong>应用软件</strong>又被称为应用程序，他是根据用户根据任务需要编制的各种程序</p><ol><li>科学计算程序</li><li>数据处理程序</li><li>过程控制程序</li><li>事务管理程序等</li></ol><h3 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h3><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202204281528705.png" alt="简单的系统层次结构"></p><p>计算机汇编语言没有通用性，每一台机器必须有一种与之对应的汇编语言，不利于计算机的广泛应用与发展，然后在20世纪60年代先后出现了各种各样的面向问题的高级语言，将高级语言翻译成机器语言程序的软件被称为<font color="red">语言处理系统</font>,翻译程序有两种：</p><blockquote><ol><li>一种是编译程序   </li><li>解释程序</li></ol></blockquote><p><img src="https://myblogg.oss-cn-beijing.aliyuncs.com/img/202204281541774.JPG" alt="编译和解释"></p><ul><li><strong>编译程序</strong>：是将用户编写高级语言程序的全部语句一次翻译成机器语言程序，而后再执行机器语言程序。因此只要源程序不变，就无须再次进行翻译，由高级语言，一次变换直接变为机器语言,生成为<code>.exe</code>的文件,那翻译来说，就是每次翻译一句写下来，一次性写完后，下次再次使用的时候，直接看自己写完的就可以了。(c语言、c++)</li><li><strong>解释程序</strong>：是将源程序的一条语句翻译对应于机器语言的一条语句，并且立即执行这条语句。它的特点是翻译一次执行一次，下次执行也必须进行翻译，相当于一个翻译机一次翻译一句，即使每次说的相同也必须再次进行翻译。（JS、python）</li></ul><p>多条微指令可以构成一条微程序，因为程序往往是需要多个操作的，如：CPU发出读指令和写指令等等，而计算机执行的其实是一个一个微指令。</p><h2 id="计算机组成和计算机体系结构"><a href="#计算机组成和计算机体系结构" class="headerlink" title="计算机组成和计算机体系结构"></a>计算机组成和计算机体系结构</h2><blockquote><font color="red">此处的**透明**--看不见</font><p>计算机体系结构</p></blockquote><ul><li><strong>计算机体系结构</strong>：是指可以被程序员看到的属性，这些属性通常指的是机器语言编程的程序员进行编写的,包括包括指令集、数据类型、储存寻址技术、I\O机理等。如果不同就是认为这两种机器的结构是各不相同的。<strong>如何设计硬件与软件之间的接口</strong>,如：<font color="red">有无乘法指令</font></li></ul><blockquote><p>计算机组成（原理）</p></blockquote><ul><li><strong>计算机组成</strong>:如何实现计算机体系结构所体现的属性，它包括了许多对于程序员透明的硬件细节，如：指令系统体现了机器的属性，这是数属于计算机结构问题，但是指令的实现，即如何取指令、取操作数，运算、送结构，这些都属于计算机组成。，因此当两台机器指令系统相同的时候，只能认为他们具有相同的结构。<strong>如何用硬件实现所定义的接口，对程序员<font color="red">“透明”</font></strong>,<font color="red">如何实现乘法指令.</font></li></ul><h2 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h2><p>说到计算机的基本组成就不得不说一下冯·诺依曼研究的EDVAC提出的”存储程序”的概念，当然这是废话没啥用了解就好</p><p>重要的了解关于他的特点，这些特点到现在有些一直还沿用至今</p><ul><li>计算机由运算器、存储器、控制器、I/O（input output）也就是输入设备和输出设备</li><li>指令和数据以同等低位存放与存储器内，可按地址寻访，<font color="red">是地址还是指令不在于他的存放在存储器的位置而是在与他是由哪一个总线(BUS)(总线会在后面进行集中的讲解)进行传输的，或者最终存放与CPU中的哪一个寄存器中，对于一段01代码他即可一表示指令，也可以表示一个二进制数</font></li><li>指令和数据都用二进制数表示，因为二进制的运算规则比较简单</li><li>指令由操作码和地址码组成，操作码表示操作的性质（读、写、加、减、位运算等），地址码用来表示操作数在存储器中的位置。</li><li>指令在存储器中按顺序存放，通常指令是按顺序执行的，但是也可以在某一个指令后面加入跳转指令，但是大多还都是顺序执行</li><li>机器以<strong>运算器</strong>为中心，输入设备输出设备间的数据传送通过运算器完成<font color="red">（这点现在已经改了）</font></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/042116112.html"/>
      <url>/2022/042116112.html</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="位运算的分类"><a href="#位运算的分类" class="headerlink" title="位运算的分类"></a>位运算的分类</h2><p><font color='red'>按位运算</font>：左移、右移、按位与按位或、异或、 取反,取相反数</p><ul><li><p>右移：<code>&gt;&gt;</code>右移一位相当于 /2 常见用法 <code>mid=(l-r)&gt;&gt;1+l;</code>用这种方法可以避免<code>mid=(l+R)/2</code><font color='red'>l+R</font>会超过int的范围的问题，并且位运算的速度比<code>mid=(l-r)&gt;&gt;1+l;</code>的速度快很多</p></li><li><p>左移 :<code>&lt;&lt;</code>左移一位相当于 *2 没什么好说的就是速度比较快</p></li><li><p>按位与:<code>&amp;</code>都为一为一其他为0<code>0&amp;0=0</code> <code>0&amp;1=1</code> <code>1&amp;1=1</code></p></li></ul><pre class=" language-lang-c"><code class="language-lang-c">01010110        &01001001</code></pre><p>按位与的结果</p><pre class=" language-lang-c"><code class="language-lang-c">01000000</code></pre><ul><li><p>按位或：<code>|</code>  <code>1|1=1</code>、 <code>1|0=1</code>、 <code>0|0=0</code></p></li><li><p>异或：<code>^</code>,可以理解为无进位加法 <code>1^1=0</code>、<code>0^1=1</code>、<code>0^0=0</code></p></li><li><p>取反：<code>~</code>取反包含符号位<code>0</code>全部变为<code>1</code>,<code>1</code>全部变为<code>0</code>.</p></li><li><p>取相反数：<code>-</code>,这是一个复杂的过程 有符号正数在内存中的存储为 原码第一位符号位为0<br>而负数在内存中的存储为补码 先把正数的符号位变为1然后去反加一就可以了</p></li></ul><pre class=" language-lang-c"><code class="language-lang-c">010011 //原码101100//取反 第一位变为1表示负数101101//加一变为对应的负数</code></pre><h2 id="位运算的应用"><a href="#位运算的应用" class="headerlink" title="位运算的应用"></a>位运算的应用</h2><p>-n=~n+1；</p><p>如何得到一个数的最低位的1：</p><pre class=" language-lang-c"><code class="language-lang-c">x=n;t=x&(~n+1)</code></pre><p>如何得到一个数的最高位：可以利用循环不断左移、知道为0记录个数n然后pow（2，n）;或者下面这种方法，这一种学习的时候看了一个人按位运算的求法的播客但是找不到了，就没发了</p><pre class=" language-lang-c"><code class="language-lang-c">int cnt=0;int x;//带去最高位的数while(x!=0){    x>>1;};int d=pow(2,n);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树的调整方法</title>
      <link href="/2022/042016111.html"/>
      <url>/2022/042016111.html</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树的调整方法"><a href="#AVL树的调整方法" class="headerlink" title="AVL树的调整方法"></a>AVL树的调整方法</h1><blockquote><p>AVL树的特性</p><ul><li>他的左子树的节点数据小于根节点的数据，根节点的数据小于右子树节点的数据  </li><li>他的左右子树的高度差的绝对值小于1<br>AVL树节点的定义：</li></ul></blockquote><pre class=" language-lang-c"><code class="language-lang-c">typedef struct TreeNode {    int data;    int height;    struct TreeNode* lchild;    struct TreeNode* rchild;};TreeNode;</code></pre><p>下面来讲调整方法，<font color="blue">顺时针旋转为左，逆时针旋转为右</font></p><ul><li>ll也就是我们说的左左调整</li></ul><p><img src="https://img-blog.csdnimg.cn/da1c02312ab14b2abb84732ca654ca83.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>总的来说：<strong>就是根成为他左孩子的右孩子，因为根节点一定大于他的左孩子，只能把他调为左孩子的右孩子，左孩子变为根节点</strong>，这样才可以符合AVL树的特点，左右子树的高度差小于1，在调整后<strong>一定一定不要忘了调整节点的高度</strong>,不然在判断的时候会引起连锁反应导致真没也无法调平<br><img src="https://img-blog.csdnimg.cn/761180a5180b41f5bb6d0244fae92308.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>调整思路：将根节点的左孩子也就是现在的3当成新的根，把原来的根也就是7，因为他肯定大于他原来的左孩子3，所以他一定会变成现在的根3的右孩子，而原来3的右孩子4一定小于原来的根7，所以就放到7的左边成为他的左孩子，<strong>切记原有的二叉树己经改变，需要更新新的节点的高度</strong></p><ul><li><p>rr调整也就是我们说的右右调整<br><img src="https://img-blog.csdnimg.cn/1291216922834328aa5065aef42af66b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>调整思路：和刚才思路差不多就不过多解释了，原来根节点的右孩子10成为现在的根节点，10的左孩子9大于4变为4的右孩子<br><strong>切记一定要及时更新调整节点的高度，不然会影响后续的调整！</strong></p></li><li><p>lr调整<br><img src="https://img-blog.csdnimg.cn/4edf23a5cca442e69020f1696e727ca4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></li></ul><p>rl调整也和lr也一样，先对根节点的右子树进行l调整在对根节点进行r调整<strong>切记一定要及时更新调整节点的高度，不然会影响后续的调整！</strong></p><ul><li>rl调整<br>和lr调整一样就是变为先ll在rr了<br><img src="https://img-blog.csdnimg.cn/8d47d9f413fe4644b5258953083a7c41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/665367835034418db94b45f568d71026.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d7da344c26f74b72b782fecb70242872.png#pic_center" alt="在这里插入图片描述"></li></ul><p><strong>简便的记忆插入右导致其变的失去平衡就要lr反正rl前提得是两次调整</strong></p><h2 id="AVL是一个特殊的树（代码笔记）"><a href="#AVL是一个特殊的树（代码笔记）" class="headerlink" title="AVL是一个特殊的树（代码笔记）"></a>AVL是一个特殊的树（代码笔记）</h2><p><em>它的特征</em>：</p><ol><li><p>他的左子树节点的数据小于根节点的数据，根节点的数据小于右子树节点的数据</p></li><li><p>他的左右子树的高度差的绝对值小于2</p></li></ol><p>所以<strong>AVL树有较高的查找效率</strong></p><p>在我们插入的过程中可能会把原来的AVL树变的不平下面展示两种情况，剩下的就是类似</p><p>节点的代码以及相关函数的定义</p><pre class=" language-lang-c"><code class="language-lang-c">typedef int date;typedef struct Treenode{    date dates;    int height;    struct Treenode* rchild;    struct Treenode* lchild;};Treenode;int max(int a,int b){    return a>b ? a:b;};int getHeight(Treenode* b){    return b ? b->height:0;};</code></pre><h3 id="ll调整"><a href="#ll调整" class="headerlink" title="ll调整"></a>ll调整</h3><p>当我们插入的节点比任何节点都要小的时候就可能会形成下面的情况导致失衡<br><img src="https://img-blog.csdnimg.cn/48f0735fe0944b7cae4811c098b09c05.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATE1NMTMxNDUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>为了便于理解画了个简单点的图<br><img src="https://img-blog.csdnimg.cn/484a0ff40c3340d2b1a5b03b5b2a648f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATE1NMTMxNDUyMQ==,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>中间的节点变为根，中间节点的右孩子为原来的根<br>因为中间节点如果有右孩子他应该链接到原来的跟上面<br>因为根成为了中间节点的右孩子，他比跟要小所以他要成为原来的根的左孩子然后更新根节点的指向<br>他就会调平<br>代码实现</p><pre class=" language-lang-c"><code class="language-lang-c">void llRotation(Treenode* node,Treenode** root){    Treenode* temp=node->lchild;    node->lchild=temp->rchild;    temp->rchild=node;    //avl树发生变化需要更新节点高度    node->height=max(getHeight(node->lchild),getHeight(node->rchild))+1;    temp->height=max(getHeight(temp->lchild),getHeight(temp->rchild))+1;    *root=temp;};</code></pre><h3 id="rr调整"><a href="#rr调整" class="headerlink" title="rr调整"></a>rr调整</h3><p>当我们插入的节点比其他节点都要小但是比根节点的左子树节点大的时候就可能会形成下面的情况导致失衡</p><p><img src="https://img-blog.csdnimg.cn/acde9fb7b808445b845ca25eb5a5ca27.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATE1NMTMxNDUyMQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>为了便于理解画了个简单的图<br><img src="https://img-blog.csdnimg.cn/43656b542d0a449c8a086be7c33fec44.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATE1NMTMxNDUyMQ==,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>因为下面节点的值大于中间节点面的值，把两个互换后他就会变为变为ll调整因为大小关系<br>代码实现<br>llRotation上面已经实现</p><pre class=" language-lang-c"><code class="language-lang-c">void llRotation(Treenode*node,Treenode** root);void rrRotation(Treenode*node,Treenode** root){    Treenode *temp=node->rchild;    node->rchild=temp->lchild;    temp->lchild=node;    node->height=max(getHeight(node->lchild),getHeight(node->rchild))+1;    temp->height=max(getHeight(temp->lchild),getHeight(temp->rchild))+1;    *root=temp;};</code></pre><p>rr已经实现<br>rl类比思考就可以得到</p><h3 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h3><pre class=" language-lang-c"><code class="language-lang-c">#include<stdio.h>#include<stdlib.h>//ll r 右转或顺时针旋转//rr l//lr lr//rl rltypedef int date;typedef struct Treenode{    date dates;    int height;    struct Treenode* rchild;    struct Treenode* lchild;};Treenode;int max(int a,int b){    return a>b ? a:b;};int getHeight(Treenode* b){    return b ? b->height:0;};void llRotation(Treenode* node,Treenode** root){    Treenode* temp=node->lchild;    node->lchild=temp->rchild;    temp->rchild=node;    //avl树发生变化需要更新节点高度    node->height=max(getHeight(node->lchild),getHeight(node->rchild))+1;    temp->height=max(getHeight(temp->lchild),getHeight(temp->rchild))+1;    *root=temp;};void rrRotation(Treenode*node,Treenode** root){    Treenode *temp=node->rchild;    node->rchild=temp->lchild;    temp->lchild=node;    node->height=max(getHeight(node->lchild),getHeight(node->rchild))+1;    temp->height=max(getHeight(temp->lchild),getHeight(temp->rchild))+1;    *root=temp;};void avlinsert(Treenode** node,date a){    if(*node==NULL)//创建第一个节点并初始化    {        *node=(Treenode*)malloc(sizeof(Treenode));        (*node)->height=0;        (*node)->lchild=NULL;        (*node)->rchild=NULL;        (*node)->dates=a;    };    else if ((*node)->dates>a)    {        avlinsert(&(*node)->lchild,a);        int lHeigh=getHeight((*node)->lchild);        int rHeigh=getHeight((*node)->rchild);        if(lHeigh-rHeigh==2)        {            //ll调整            if((*node)->lchild->dates>a)            {                llRotation(*node,node);            };            else            {                rrRotation((*node)->lchild,&(*node)->lchild);                llRotation(*node,node);            };        };    };    else if ((*node)->dates<a)    {        avlinsert(&(*node)->rchild,a);        //拿到左右子树高度        int lHeigh=getHeight((*node)->lchild);        int rHeigh=getHeight((*node)->rchild);        if(rHeigh-lHeigh==2)        {            if((*node)->rchild->dates<a)            {                rrRotation(*node,node);            };            else            {                llRotation((*node)->rchild,&(*node)->rchild);                rrRotation(*node,node);            };        };       };    (*node) -> height = max(getHeight((*node) -> lchild), getHeight((*node) -> rchild)) + 1;};void preOrder(Treenode* T){    if (T)     {        printf("%d ", T -> dates);        preOrder(T -> lchild);        preOrder(T -> rchild);    };};int main(){    Treenode* T=NULL;    int nums[5] = {1,8,6,7,10};;    for (int i = 0; i < 5; i++) {        avlinsert(&T, nums[i]);    };    preOrder(T);    printf("\n");};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> AVL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2022/041916110.html"/>
      <url>/2022/041916110.html</url>
      
        <content type="html"><![CDATA[<h1 id="142-环形链标II"><a href="#142-环形链标II" class="headerlink" title="142.环形链标II"></a>142.环形链标II</h1><p><strong>题目地址</strong>：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><blockquote><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始）</strong>。如果 pos 是 -1，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。<br><strong>不允许</strong>修改链表。<br><strong>示例 1：</strong><br><img src="https://img-blog.csdnimg.cn/2d6cc098e07546539f5f64b2a48f258b.png#pic_center" alt="环形链表1"></p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><blockquote><p><strong>示例 2：</strong><br><img src="https://img-blog.csdnimg.cn/7ddb4e4f9fad429bab1d44b75b4ea2dc.png#pic_center" alt="环形链表2"></p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><blockquote><p><strong>示例 3：</strong><br><img src="https://img-blog.csdnimg.cn/bbf0a4bc03984b18a29c3ba17342dfda.png#pic_center" alt="环形链表3"></p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>总体思路是快慢指针法，就是一个show指针一次走一步fast指针一次走两步，如果有环的话，当两个指针同时进入环后，他们之间的举例以一的次数减少，每次移动间隔减少一，他们必定会相遇，如果是三和五没有尝试读者可以尝试在评论区说一下可不可以。  </p><blockquote><p><strong>下面就是他们如果相遇fast就是快指针走的路程 slow就是慢指针走的路程 环外的路程为a 环的长度为b</strong>当他们相遇的时候：<br>$fast=2slow$<br>$fast=slow+nb$(相遇的时候fast比slow多走环的整数倍)<br>所以：<br>$slow=nb$<br>$fast=2nb$<br>又因为：<br>链表长度的入口节点位置：$s=a+nb$<br>$slow+a=s$<br>所以ptr=head向前每次向前一其必和slow在入口节点相遇<br>相遇的地方就是a 再来一个双指针法，此指针和slow 一起向前走 a 步后，两者在入口节点重合。</p></blockquote><h2 id="代码实现-c语言版本"><a href="#代码实现-c语言版本" class="headerlink" title="代码实现(c语言版本)"></a>代码实现(c语言版本)</h2><pre class=" language-lang-c"><code class="language-lang-c">struct ListNode *detectCycle(struct ListNode *head) {    if(!head)    {        return NULL;    };    struct ListNode *show=head;    struct ListNode *fast=head;    struct ListNode *ptr=head;    while(fast->next&&fast->next->next)    {        show=show->next;        fast=fast->next->next;        if(show==fast)        {            while(show!=ptr)            {                show=show->next;                ptr=ptr->next;            };            return show;        };    };    return NULL;};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2022/041816109.html"/>
      <url>/2022/041816109.html</url>
      
        <content type="html"><![CDATA[<h1 id="七大常用排序算法"><a href="#七大常用排序算法" class="headerlink" title="七大常用排序算法"></a>七大常用排序算法</h1><p>[TOC]</p><p><strong>前言：</strong> 在学习这些排序算法前我们都应该了解一些关于时间<strong>复杂度</strong>和<strong>空间复杂度</strong>的相关知识了，下面简略的介绍一下，顺便在提一下一个新的性质来衡量算法的标准 <strong>稳定性</strong></p><ul><li><strong>时间复杂度</strong>：对于排序算法来说，就是随着排序规模的增加，排序时间增加的速度满足的一个函数关系，这个函数关系是不包括函数的低阶项，和最高项前面的系数的<br>—<strong>tips</strong>：<br><font color="red">递归的O()</font>  注意：<strong>子问题需要相同</strong><script type="math/tex; mode=display">T(N)=a*T(N/b)+O(N^d)</script></li><li><p>T(N)|T(N/b)|a|O(N^d)<br>  :—-:|:—-:|:—-:|:—-:<br>  母问题|子问题的规模|子问题被调用次数|出了递归调用子问题的时间复杂度  </p></li><li><p>$log_b a$<d|$log_b a>d$|$log_b a=d $<br>  :—-:|:—-:|:—-:<br>  $ O(N^d) $|$ O(N^{log_ba}) $|$ (N^b*log N) $</p></li><li><p><strong>空间复杂度</strong>：随着排序规模的正价，排序所需要的空间的函数关系，他与定义的变量与数组指针等有关系，可以非常直观的看出，这个函数关系同样是不包括函数的低阶项，和最高项前面的系数的</p></li><li><p><strong>稳定性</strong>：就是在排序的过程中不改变相同元素的次序，那么怎么来理解呢？<br><img src="https://img-blog.csdnimg.cn/8f781c13456044d99db6290f0b7748d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>这对于基础数据的作用作为衡量指标意义不是特别大，但是对于对象等在实际的应用中应用非常广泛，<strong>例如</strong>：当我们在淘宝购物的时候，我们会先以好评率排序然后按照价格排序，这样我们就可以得到物美价廉的商品，但是如果两个排序都没有稳定性，这是无法实现的，就算实现了，所需要的时间和空间开销也是非常恐怖的了。</p></li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li>思路：<br>冒泡排序应该是我们接触的第一个排序，<font color="red">排序的过程就像水里的气泡一样越向水面气泡越大</font>，这个是非常经典的排序算法<font color="red">这里以升序为例，降序不过是吧水面和水底进行了换位置，虽然这在现实生活中是违背物理规律的:flushed: 但是水面和水底只是一个形象的比喻而已:flushed:</font></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(N^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">√</td></tr></tbody></table></div><ul><li>下面是关于这个算法的图解<br><img src="https://img-blog.csdnimg.cn/845a27ff47d54107925a5917eda21786.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f76e1af11a454ade9099f55b4fb84b93.gif#pic_center" alt="在这里插入图片描述"></li></ul><p>每一次遍历就可以把最大的数放到追后面</p><hr><pre class=" language-lang-c"><code class="language-lang-c">//交换两个数void swap(int *a,int* b){    int c=*a;    *a=*b;    *b=c;};//排序算法void BubbleSort(int *arr,int length){    for(int i=0;i<length;i++)    {        //每一遍少跑一个元素        for(int x=0;x<length-i-1;x++)        {            if(arr[x]>arr[x+1])            {                swap(&arr[x],&arr[x+1]);            };        };    };};</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><hr><p><strong>思想：</strong><br>&emsp;插入排序相当于摸纸牌，每次摸<strong>一张</strong>把他插到相应的位置上。</p><font color="red">每一次插入一个新的牌和前面的牌进行比较，如果一直到不在比前一张大结束或者到数组的开始结束。</font>时间复杂度|空间复杂度|稳定性:--:|:--:|:--:$O(N^2)$|$O(1)$|√![在这里插入图片描述](https://img-blog.csdnimg.cn/a5733bfb2eb241a6854d0f8ad3ef2219.gif#pic_center)---```cvoid swap(int* a,int *b){    int c=*a;    *a=*b;    *b=c;}void insertsort(int *arr,int length){    for(int i=0;i<length;i++)    {        for(int x=i;x>0;x--)        {            if(arr[x]<arr[x-1])            {                swap(&arr[x],&arr[x-1]);            }        }    }}```## 希尔排序---- **思想：**&emsp;希尔排序相当于插入排序的一个优化，插入排序每次遍历的步长为一，而希尔排序是把序列按照下标进行分类，然后进行插入排序的算法，这可以形象的看成每一次遍历的步长为gap，gap要视元素的个数而定，可以更快的让较大的数跑到后面，然后每次让gap缩小，缩小到1后就成了完完全全的插入排序或者更小的数跑到前面，希尔排序的时间复杂度比较复杂，直接记着就好时间复杂度|空间复杂度|稳定性:--:|:--:|:--:$O(N^{1.2})$~$O(N^{1.5})$|$O(1)$|×---下面举一个例子：![在这里插入图片描述](https://img-blog.csdnimg.cn/5450d682ae524a92a0124bf62eeddf0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)**如果gap=3**那么下标的分组为：```c0 3 6 9 1 4 7 102 5 8 11```对每一组进行插入排序后：![在这里插入图片描述](https://img-blog.csdnimg.cn/7b1c40ed04d740bcb0e4a46c54490118.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)```cgap=gap/2//此时gap=1也就是插入排序 ```然后变为:![在这里插入图片描述](https://img-blog.csdnimg.cn/8454c2abad1e4302a88a800b6de4af1b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)排序完成---下面给一个动图的例子![在这里插入图片描述](https://img-blog.csdnimg.cn/974473590600471196623b85e389db03.gif#pic_center)<font color="red">注意事项:1.<font color="red"> gap每次缩小应该能保证最后缩小到1进行插入排序不然排序过程无法完成，用每次除2一定最后可以缩小得到1 如果要除3可能得不到1 6/3=2 2/3=0 导致排序无法完成 可以```gap=gap/3+1```来进行保证</font>2. <font color="red">gap的选取一定要合理不然无法达到特别明显的速度提升还损失稳定性得不偿失</font></font><p>代码实现:</p><pre class=" language-lang-c"><code class="language-lang-c">void pai(int *a,int n)//希尔排序{    int gap=n;    while(gap>1)    {        gap=gap/2;    for (int i = 0; i < n-gap; i++)    {        int end=i;        int gold=a[end+gap];        while(end>=0)        {            if(a[end]>gold)            {                a[end+gap]=a[end];                end=end-gap;            };            else            {                break;            };        };        a[end+gap]=gold;    };    };};</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>快速排序思想<br>&emsp;快排产生于荷兰国旗问题，他是找寻一个目标值让这个目标值左边的数都比他小，右边的数都比他大，这样便找到了这个数原来应该存在的位置，然后递归调用拓展到数组的每一个元素便实现了排序，听着很简单对吧，但是千万别大意啊，这个排序的应用非常广泛，实现也有一些需要闭坑的点。传统意义的快排时间复杂度$O(N^2)$空间复杂度$O(log_N)$经过改进后时间复杂度也是比较难求的</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(log_N)$</td><td style="text-align:center">×</td></tr></tbody></table></div><hr><p>举一个具体的例子，拿数组最右边的值当做目标值，把他当做右边界（大于区）大于区的扩增是指针—，左边界为-1：</p><ul><li>当i指针指向的值大于目标值的时候与大于区的下一个元素进行交换，右边界—；</li><li>当i指针指向的值等于目标值的时候 i++；</li><li>当i指向的值小于目标值与小于区前一个元素进行交换小于区扩张 i++；</li><li>最后把数组最右边的元素和大于区的前一个元素进行交换 右边界++就可以了</li></ul><p><img src="https://img-blog.csdnimg.cn/ad0f9493b68b4261a600d656a60dabc1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9ae6b3a7208f4876ae9e9e3181741713.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8a66baae05714b27b5977191d16f54e4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/738ce1b2677e4d31a9dec0fff1dab7f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>        .<br>        .<br>        .</p><p><img src="https://img-blog.csdnimg.cn/fc861b5e9aa44fde9d45f14c2177e7f7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ce1a8b73298b48f9b0a1420cbf711d17.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>最后一定要返回左右边界的指针<br>中间省略了一点图，目标值一定要随机进行选择优化，不要固定为最后一个值不然有一定几率$O(N^2)$。</p><p><strong>代码实现：</strong></p><pre class=" language-lang-c"><code class="language-lang-c">srand(time(NULL) + rand());//产生随机数swap(arr, l + rand() % (r - l + 1), r);//把随机数放到最后</code></pre><pre class=" language-lang-c"><code class="language-lang-c">//快排void swap(int* arr, int l, int r){    /*    arr[l]=arr[l]^arr[r];    arr[r]=arr[l]^arr[r];//arr[r]=arr[l];    arr[l]=arr[l]^arr[r];*/    int c = arr[l];    arr[l] = arr[r];    arr[r] = c;    //printf("arr[%d]=%d arr[%d]=%d\n",l,arr[l],r,arr[r]);};int* partition(int* arr, int l, int r){    int less = l - 1;//小于目标值的左边界    int more = r;//大于目标值的右边界    while (l < more)    {        if (arr[l] < arr[r])        {            swap(arr, ++less, l++);        };        else if (arr[l] > arr[r])        {            swap(arr, l, --more);        };        else if (arr[l] == arr[r])        {            l++;        };    };    swap(arr, more++, r);    int* p = (int*)malloc(sizeof(int) * 2);    p[0] = less + 1;    p[1] = --more;    return p;};void quicksort(int* arr, int l, int r){    if (l == r || !arr)    {        return;    };    if (l < r)    {        srand(time(NULL) + rand());//产生随机数        swap(arr, l + rand() % (r - l + 1), r);        //printf("arrx[%d]=%d\n",r,arr[r]);        int* px = (int*)malloc(sizeof(int) * 2);        px = partition(arr, l, r);        //printf("p[0]=%d p[1]=%d \n",p[0],p[1]);        quicksort(arr, l, px[0] - 1);        quicksort(arr, px[1] + 1, r);    };};</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>在讲解堆排序之前我们应该了解的两种二叉树就是什么是满二叉树什么是完全二叉树</p><ol><li><p>完全二叉树：设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，<br>第 h 层所有的结点都连续集中在最左边</p></li><li><p>满二叉树：深度为k且有2^k-1个结点的二叉树称为满二叉树</p></li></ol><hr><p>而我们所说的堆排序就需要构建完全二叉树（用数组的方式进行构建）下面给出两个重要的关系：<br><strong>假设父亲的下标为n</strong><br>当然这个父亲节点不可以为叶子节点</p><ol><li>左孩子=2n+1</li><li>右孩子=2n+2</li></ol><p>完全二叉树的前n-1层的节点个数一定是$1+2^1+ 2^2*……2^n-1$<br>堆分为大根堆和小根堆</p><ol><li>最大堆（大根堆）：根结点的键值是所有堆结点键值中最大者。</li><li>最小堆（小根堆）：根结点的键值是所有堆结点键值中最小者。</li></ol><hr><p><strong>排升序要用小根堆，排降序要用大跟堆</strong><br>堆排序的核心是向下调整算法<br>就是一个二叉树的左右子树都满足大根堆或者是小根堆<br>就以 小根堆为例： 要保证是自己是小根堆前提要自己的孩子为小根堆,这显然是一个递归问题 然后把堆顶的元素和最后一个元素交换然后把最后一个元素t出推因为堆顶的元素一定大于或者小于堆中的任意一个元素，继续进行调整就可以了</p><div class="table-container"><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">×</td></tr></tbody></table></div><font color="red">算法思路：1 .先调最底的树 堆的长度/2就是最后一个元素的父亲 左孩子和右孩子的最大值成为与父节点的值进行交换领整个数组成为一个小根堆或者大根堆2 .在每一次堆顶的元素和堆底元素交换后调整堆，因为交换前，堆顶元素的左孩子和右孩子也一定为小根堆或者都为大根堆，调整一次即可重复这个过程</font><pre class=" language-lang-c"><code class="language-lang-c">void swap(int*a ,int*b){    int c=*a;    *a=*b;    *b=c;};void just(int*a,int root,int n){    int child=2*root+1;;    int parent=root;    while(2*parent+1<n)    {        if(child+1<n&&a[child]<a[child+1])        {            child=child+1;        };        if(a[parent]<a[child])        {            swap(&a[child],&a[parent]);            parent=child;            child=2*parent+1;        };        else        {            break;        };    };};void pai2(int *a,int root,int n)//堆排序{    //建堆    for(int i=(n-1)/2;i>=0;i--)    {        just(a,i,n);    };    int end=n-1;    while(end>0)    {        swap(&a[0],&a[end]);        just(a,0,end);        end--;    };};</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>先让一个数组的左边有序，数组的右边有序，然后在让一个数组的右边有序，然后再让整个数组有序就可以了，这显然也是一个递归调用的问题，每一次都把数组分成两部分重复解决这个问题<code>数组的右边有序，然后在让一个数组的右边有序，然后再让整个数组有序就可以了</code>这个排序不像堆排序那样好理解让我们看图解,同时应该看着代码看着图进行理解</p><div class="table-container"><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(N)$</td><td style="text-align:center">√</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/aa7bd0c23c154e90a87dc741d11591fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/381bacfe64434ebd8534f3165a16e65c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4d26faa4fb8d40569483672c1d40ab80.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b013bebc79ef4169b62b0aa49a7b88bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>那么每一次递归如何让他有序呢？<br><img src="https://img-blog.csdnimg.cn/749fe540bdf54971b3a3656ecfe8e242.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/938a774448b141be99cdd5c1aae3c890.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>代码实现：</p><pre class=" language-lang-c"><code class="language-lang-c">void merge(int *arr,int L,int M,int R){    int *help=(int*)malloc(sizeof(int)*(R-L+1));    int i=0;    int p1=L;    int p2=M+1;    while (p1<=M&&p2<=R)    {        help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];    };    while (p1<=M)    {        help[i++]=arr[p1++];    };    while (p2<=R)    {        help[i++]=arr[p2++];    };    for(int i=0;i<R-L+1;i++)    {        arr[L+i]=help[i];//注意是最左边开始    };    free(help);};void process(int*arr ,int L,int R){    if(L==R)    {        return ;    };    int mid=L+((R-L)>>1);    //merge(arr,L,mid,R);    process(arr,L,mid);    process(arr,mid+1,R);    merge(arr,L,mid,R);};</code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>这个排序有点特殊需要具体问题具体分析，需要开一个数组和原来数组元素类型数量一样，然后对每一个元素进行计数，不在详细讲<br>看图理解就好</p><p><img src="https://img-blog.csdnimg.cn/430fa09820174f3782e9b286135742cd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">排序</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡</td><td style="text-align:center">$O(N^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">$O(N^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(N^{1.2})$~$O(N^{1.5})$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(log_N)$</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(N)$</td><td style="text-align:center">√</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/041816107.html"/>
      <url>/2022/041816107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
