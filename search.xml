<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode</title>
      <link href="/2022/041916110.html"/>
      <url>/2022/041916110.html</url>
      
        <content type="html"><![CDATA[<h1 id="142-环形链标II"><a href="#142-环形链标II" class="headerlink" title="142.环形链标II"></a>142.环形链标II</h1><p><strong>题目地址</strong>：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><blockquote><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始）</strong>。如果 pos 是 -1，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。<br><strong>不允许</strong>修改链表。<br><strong>示例 1：</strong><br><img src="https://img-blog.csdnimg.cn/2d6cc098e07546539f5f64b2a48f258b.png#pic_center" alt="环形链表1"></p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><blockquote><p><strong>示例 2：</strong><br><img src="https://img-blog.csdnimg.cn/7ddb4e4f9fad429bab1d44b75b4ea2dc.png#pic_center" alt="环形链表2"></p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><blockquote><p><strong>示例 3：</strong><br><img src="https://img-blog.csdnimg.cn/bbf0a4bc03984b18a29c3ba17342dfda.png#pic_center" alt="环形链表3"></p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>总体思路是快慢指针法，就是一个show指针一次走一步fast指针一次走两步，如果有环的话，当两个指针同时进入环后，他们之间的举例以一的次数减少，每次移动间隔减少一，他们必定会相遇，如果是三和五没有尝试读者可以尝试在评论区说一下可不可以。  </p><blockquote><p><strong>下面就是他们如果相遇fast就是快指针走的路程 slow就是慢指针走的路程 环外的路程为a 环的长度为b</strong>当他们相遇的时候：<br>$fast=2slow$<br>$fast=slow+nb$(相遇的时候fast比slow多走环的整数倍)<br>所以：<br>$slow=nb$<br>$fast=2nb$<br>又因为：<br>链表长度的入口节点位置：$s=a+nb$<br>$slow+a=s$<br>所以ptr=head向前每次向前一其必和slow在入口节点相遇<br>相遇的地方就是a 再来一个双指针法，此指针和slow 一起向前走 a 步后，两者在入口节点重合。</p></blockquote><h2 id="代码实现-c语言版本"><a href="#代码实现-c语言版本" class="headerlink" title="代码实现(c语言版本)"></a>代码实现(c语言版本)</h2><pre class=" language-lang-c"><code class="language-lang-c">struct ListNode *detectCycle(struct ListNode *head) &#123;    if(!head)    &#123;        return NULL;    &#125;    struct ListNode *show=head;    struct ListNode *fast=head;    struct ListNode *ptr=head;    while(fast->next&&fast->next->next)    &#123;        show=show->next;        fast=fast->next->next;        if(show==fast)        &#123;            while(show!=ptr)            &#123;                show=show->next;                ptr=ptr->next;            &#125;            return show;        &#125;    &#125;    return NULL;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2022/041816109.html"/>
      <url>/2022/041816109.html</url>
      
        <content type="html"><![CDATA[<h1 id="七大常用排序算法"><a href="#七大常用排序算法" class="headerlink" title="七大常用排序算法"></a>七大常用排序算法</h1><p><strong>前言：</strong> 在学习这些排序算法前我们都应该了解一些关于时间<strong>复杂度</strong>和<strong>空间复杂度</strong>的相关知识了，下面简略的介绍一下，顺便在提一下一个新的性质来衡量算法的标准 <strong>稳定性</strong></p><ul><li><strong>时间复杂度</strong>：对于排序算法来说，就是随着排序规模的增加，排序时间增加的速度满足的一个函数关系，这个函数关系是不包括函数的低阶项，和最高项前面的系数的<br>—<strong>tips</strong>：<br><font color="red">递归的O()</font>  注意：<strong>子问题需要相同</strong><script type="math/tex; mode=display">T(N)=a*T(N/b)+O(N^d)</script></li><li><p>T(N)|T(N/b)|a|O(N^d)<br>  :—-:|:—-:|:—-:|:—-:<br>  母问题|子问题的规模|子问题被调用次数|出了递归调用子问题的时间复杂度  </p></li><li><p>$log_b a$<d|$log_b a>d$|$log_b a=d $<br>  :—-:|:—-:|:—-:<br>  $ O(N^d) $|$ O(N^{log_ba}) $|$ (N^b*log N) $</p></li><li><p><strong>空间复杂度</strong>：随着排序规模的正价，排序所需要的空间的函数关系，他与定义的变量与数组指针等有关系，可以非常直观的看出，这个函数关系同样是不包括函数的低阶项，和最高项前面的系数的</p></li><li><p><strong>稳定性</strong>：就是在排序的过程中不改变相同元素的次序，那么怎么来理解呢？<br><img src="https://img-blog.csdnimg.cn/8f781c13456044d99db6290f0b7748d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>这对于基础数据的作用作为衡量指标意义不是特别大，但是对于对象等在实际的应用中应用非常广泛，<strong>例如</strong>：当我们在淘宝购物的时候，我们会先以好评率排序然后按照价格排序，这样我们就可以得到物美价廉的商品，但是如果两个排序都没有稳定性，这是无法实现的，就算实现了，所需要的时间和空间开销也是非常恐怖的了。</p></li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li>思路：<br>冒泡排序应该是我们接触的第一个排序，<font color="red">排序的过程就像水里的气泡一样越向水面气泡越大</font>，这个是非常经典的排序算法<font color="red">这里以升序为例，降序不过是吧水面和水底进行了换位置，虽然这在现实生活中是违背物理规律的:flushed: 但是水面和水底只是一个形象的比喻而已:flushed:</font></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(N^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">√</td></tr></tbody></table></div><ul><li>下面是关于这个算法的图解<br><img src="https://img-blog.csdnimg.cn/845a27ff47d54107925a5917eda21786.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f76e1af11a454ade9099f55b4fb84b93.gif#pic_center" alt="在这里插入图片描述"></li></ul><p>每一次遍历就可以把最大的数放到追后面</p><hr><pre class=" language-lang-c"><code class="language-lang-c">//交换两个数void swap(int *a,int* b)&#123;    int c=*a;    *a=*b;    *b=c;&#125;//排序算法void BubbleSort(int *arr,int length)&#123;    for(int i=0;i<length;i++)    &#123;        //每一遍少跑一个元素        for(int x=0;x<length-i-1;x++)        &#123;            if(arr[x]>arr[x+1])            &#123;                swap(&arr[x],&arr[x+1]);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><hr><p><strong>思想：</strong><br>&emsp;插入排序相当于摸纸牌，每次摸<strong>一张</strong>把他插到相应的位置上。</p><font color="red">每一次插入一个新的牌和前面的牌进行比较，如果一直到不在比前一张大结束或者到数组的开始结束。</font>时间复杂度|空间复杂度|稳定性:--:|:--:|:--:$O(N^2)$|$O(1)$|√![在这里插入图片描述](https://img-blog.csdnimg.cn/a5733bfb2eb241a6854d0f8ad3ef2219.gif#pic_center)---```cvoid swap(int* a,int *b){    int c=*a;    *a=*b;    *b=c;}void insertsort(int *arr,int length){    for(int i=0;i<length;i++)    {        for(int x=i;x>0;x--)        {            if(arr[x]<arr[x-1])            {                swap(&arr[x],&arr[x-1]);            }        }    }}```## 希尔排序---- **思想：**&emsp;希尔排序相当于插入排序的一个优化，插入排序每次遍历的步长为一，而希尔排序是把序列按照下标进行分类，然后进行插入排序的算法，这可以形象的看成每一次遍历的步长为gap，gap要视元素的个数而定，可以更快的让较大的数跑到后面，然后每次让gap缩小，缩小到1后就成了完完全全的插入排序或者更小的数跑到前面，希尔排序的时间复杂度比较复杂，直接记着就好时间复杂度|空间复杂度|稳定性:--:|:--:|:--:$O(N^{1.2})$~$O(N^{1.5})$|$O(1)$|×---下面举一个例子：![在这里插入图片描述](https://img-blog.csdnimg.cn/5450d682ae524a92a0124bf62eeddf0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)**如果gap=3**那么下标的分组为：```c0 3 6 9 1 4 7 102 5 8 11```对每一组进行插入排序后：![在这里插入图片描述](https://img-blog.csdnimg.cn/7b1c40ed04d740bcb0e4a46c54490118.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)```cgap=gap/2//此时gap=1也就是插入排序 ```然后变为:![在这里插入图片描述](https://img-blog.csdnimg.cn/8454c2abad1e4302a88a800b6de4af1b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)排序完成---下面给一个动图的例子![在这里插入图片描述](https://img-blog.csdnimg.cn/974473590600471196623b85e389db03.gif#pic_center)<font color="red">注意事项:1.<font color="red"> gap每次缩小应该能保证最后缩小到1进行插入排序不然排序过程无法完成，用每次除2一定最后可以缩小得到1 如果要除3可能得不到1 6/3=2 2/3=0 导致排序无法完成 可以```gap=gap/3+1```来进行保证</font>2. <font color="red">gap的选取一定要合理不然无法达到特别明显的速度提升还损失稳定性得不偿失</font></font><p>代码实现:</p><pre class=" language-lang-c"><code class="language-lang-c">void pai(int *a,int n)//希尔排序&#123;    int gap=n;    while(gap>1)    &#123;        gap=gap/2;    for (int i = 0; i < n-gap; i++)    &#123;        int end=i;        int gold=a[end+gap];        while(end>=0)        &#123;            if(a[end]>gold)            &#123;                a[end+gap]=a[end];                end=end-gap;            &#125;            else            &#123;                break;            &#125;        &#125;        a[end+gap]=gold;    &#125;    &#125;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>快速排序思想<br>&emsp;快排产生于荷兰国旗问题，他是找寻一个目标值让这个目标值左边的数都比他小，右边的数都比他大，这样便找到了这个数原来应该存在的位置，然后递归调用拓展到数组的每一个元素便实现了排序，听着很简单对吧，但是千万别大意啊，这个排序的应用非常广泛，实现也有一些需要闭坑的点。传统意义的快排时间复杂度$O(N^2)$空间复杂度$O(log_N)$经过改进后时间复杂度也是比较难求的</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(log_N)$</td><td style="text-align:center">×</td></tr></tbody></table></div><hr><p>举一个具体的例子，拿数组最右边的值当做目标值，把他当做右边界（大于区）大于区的扩增是指针—，左边界为-1：</p><ul><li>当i指针指向的值大于目标值的时候与大于区的下一个元素进行交换，右边界—；</li><li>当i指针指向的值等于目标值的时候 i++；</li><li>当i指向的值小于目标值与小于区前一个元素进行交换小于区扩张 i++；</li><li>最后把数组最右边的元素和大于区的前一个元素进行交换 右边界++就可以了</li></ul><p><img src="https://img-blog.csdnimg.cn/ad0f9493b68b4261a600d656a60dabc1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9ae6b3a7208f4876ae9e9e3181741713.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8a66baae05714b27b5977191d16f54e4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/738ce1b2677e4d31a9dec0fff1dab7f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>        .<br>        .<br>        .</p><p><img src="https://img-blog.csdnimg.cn/fc861b5e9aa44fde9d45f14c2177e7f7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ce1a8b73298b48f9b0a1420cbf711d17.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>最后一定要返回左右边界的指针<br>中间省略了一点图，目标值一定要随机进行选择优化，不要固定为最后一个值不然有一定几率$O(N^2)$。</p><p><strong>代码实现：</strong></p><pre class=" language-lang-c"><code class="language-lang-c">srand(time(NULL) + rand());//产生随机数swap(arr, l + rand() % (r - l + 1), r);//把随机数放到最后</code></pre><pre class=" language-lang-c"><code class="language-lang-c">//快排void swap(int* arr, int l, int r)&#123;    /*    arr[l]=arr[l]^arr[r];    arr[r]=arr[l]^arr[r];//arr[r]=arr[l];    arr[l]=arr[l]^arr[r];*/    int c = arr[l];    arr[l] = arr[r];    arr[r] = c;    //printf("arr[%d]=%d arr[%d]=%d\n",l,arr[l],r,arr[r]);&#125;int* partition(int* arr, int l, int r)&#123;    int less = l - 1;//小于目标值的左边界    int more = r;//大于目标值的右边界    while (l < more)    &#123;        if (arr[l] < arr[r])        &#123;            swap(arr, ++less, l++);        &#125;        else if (arr[l] > arr[r])        &#123;            swap(arr, l, --more);        &#125;        else if (arr[l] == arr[r])        &#123;            l++;        &#125;    &#125;    swap(arr, more++, r);    int* p = (int*)malloc(sizeof(int) * 2);    p[0] = less + 1;    p[1] = --more;    return p;&#125;void quicksort(int* arr, int l, int r)&#123;    if (l == r || !arr)    &#123;        return;    &#125;    if (l < r)    &#123;        srand(time(NULL) + rand());//产生随机数        swap(arr, l + rand() % (r - l + 1), r);        //printf("arrx[%d]=%d\n",r,arr[r]);        int* px = (int*)malloc(sizeof(int) * 2);        px = partition(arr, l, r);        //printf("p[0]=%d p[1]=%d \n",p[0],p[1]);        quicksort(arr, l, px[0] - 1);        quicksort(arr, px[1] + 1, r);    &#125;&#125;</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>在讲解堆排序之前我们应该了解的两种二叉树就是什么是满二叉树什么是完全二叉树</p><ol><li><p>完全二叉树：设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，<br>第 h 层所有的结点都连续集中在最左边</p></li><li><p>满二叉树：深度为k且有2^k-1个结点的二叉树称为满二叉树</p></li></ol><hr><p>而我们所说的堆排序就需要构建完全二叉树（用数组的方式进行构建）下面给出两个重要的关系：<br><strong>假设父亲的下标为n</strong><br>当然这个父亲节点不可以为叶子节点</p><ol><li>左孩子=2n+1</li><li>右孩子=2n+2</li></ol><p>完全二叉树的前n-1层的节点个数一定是$1+2^1+ 2^2*……2^n-1$<br>堆分为大根堆和小根堆</p><ol><li>最大堆（大根堆）：根结点的键值是所有堆结点键值中最大者。</li><li>最小堆（小根堆）：根结点的键值是所有堆结点键值中最小者。</li></ol><hr><p><strong>排升序要用小根堆，排降序要用大跟堆</strong><br>堆排序的核心是向下调整算法<br>就是一个二叉树的左右子树都满足大根堆或者是小根堆<br>就以 小根堆为例： 要保证是自己是小根堆前提要自己的孩子为小根堆,这显然是一个递归问题 然后把堆顶的元素和最后一个元素交换然后把最后一个元素t出推因为堆顶的元素一定大于或者小于堆中的任意一个元素，继续进行调整就可以了</p><div class="table-container"><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">×</td></tr></tbody></table></div><font color="red">算法思路：1 .先调最底的树 堆的长度/2就是最后一个元素的父亲 左孩子和右孩子的最大值成为与父节点的值进行交换领整个数组成为一个小根堆或者大根堆2 .在每一次堆顶的元素和堆底元素交换后调整堆，因为交换前，堆顶元素的左孩子和右孩子也一定为小根堆或者都为大根堆，调整一次即可重复这个过程</font><pre class=" language-lang-c"><code class="language-lang-c">void swap(int*a ,int*b)&#123;    int c=*a;    *a=*b;    *b=c;&#125;void just(int*a,int root,int n)&#123;    int child=2*root+1;;    int parent=root;    while(2*parent+1<n)    &#123;        if(child+1<n&&a[child]<a[child+1])        &#123;            child=child+1;        &#125;        if(a[parent]<a[child])        &#123;            swap(&a[child],&a[parent]);            parent=child;            child=2*parent+1;        &#125;        else        &#123;            break;        &#125;    &#125;&#125;void pai2(int *a,int root,int n)//堆排序&#123;    //建堆    for(int i=(n-1)/2;i>=0;i--)    &#123;        just(a,i,n);    &#125;    int end=n-1;    while(end>0)    &#123;        swap(&a[0],&a[end]);        just(a,0,end);        end--;    &#125;&#125;</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>先让一个数组的左边有序，数组的右边有序，然后在让一个数组的右边有序，然后再让整个数组有序就可以了，这显然也是一个递归调用的问题，每一次都把数组分成两部分重复解决这个问题<code>数组的右边有序，然后在让一个数组的右边有序，然后再让整个数组有序就可以了</code>这个排序不像堆排序那样好理解让我们看图解,同时应该看着代码看着图进行理解</p><div class="table-container"><table><thead><tr><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(N)$</td><td style="text-align:center">√</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/aa7bd0c23c154e90a87dc741d11591fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/381bacfe64434ebd8534f3165a16e65c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4d26faa4fb8d40569483672c1d40ab80.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b013bebc79ef4169b62b0aa49a7b88bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>那么每一次递归如何让他有序呢？<br><img src="https://img-blog.csdnimg.cn/749fe540bdf54971b3a3656ecfe8e242.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/938a774448b141be99cdd5c1aae3c890.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>代码实现：</p><pre class=" language-lang-c"><code class="language-lang-c">void merge(int *arr,int L,int M,int R)&#123;    int *help=(int*)malloc(sizeof(int)*(R-L+1));    int i=0;    int p1=L;    int p2=M+1;    while (p1<=M&&p2<=R)    &#123;        help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];    &#125;    while (p1<=M)    &#123;        help[i++]=arr[p1++];    &#125;    while (p2<=R)    &#123;        help[i++]=arr[p2++];    &#125;    for(int i=0;i<R-L+1;i++)    &#123;        arr[L+i]=help[i];//注意是最左边开始    &#125;    free(help);&#125;void process(int*arr ,int L,int R)&#123;    if(L==R)    &#123;        return ;    &#125;    int mid=L+((R-L)>>1);    //merge(arr,L,mid,R);    process(arr,L,mid);    process(arr,mid+1,R);    merge(arr,L,mid,R);&#125;</code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>这个排序有点特殊需要具体问题具体分析，需要开一个数组和原来数组元素类型数量一样，然后对每一个元素进行计数，不在详细讲<br>看图理解就好</p><p><img src="https://img-blog.csdnimg.cn/430fa09820174f3782e9b286135742cd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a2mY-eahOWwj-adjg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">排序</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡</td><td style="text-align:center">$O(N^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">$O(N^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(N^{1.2})$~$O(N^{1.5})$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(log_N)$</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">$O(N*log_N)$</td><td style="text-align:center">$O(N)$</td><td style="text-align:center">√</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/041816107.html"/>
      <url>/2022/041816107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
